
<!DOCTYPE html>
<html lang="en"><head><title>cs184/284a</title><meta charset="UTF-8"><meta http-equiv="Content-Language" content="en"><link rel="stylesheet" href="https://unpkg.com/ionicons@4.4.2/dist/css/ionicons.min.css">
<link rel="stylesheet" href="/static/cs184-web-5d805804.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/github-markdown-css/2.2.1/github-markdown.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css"></head><body><script>$MG={"o":{"browserRefresh":false,"activeSemester":{"id":7,"tag":"sp22"},"auth":{"profile":{"id":20344265,"username":"somyam","avatar_url":"https://avatars.githubusercontent.com/u/20344265?v=4"},"user":{"id":4675,"sid":3034147770,"email":"somya.mohindra@berkeley.edu","roster_name":"Mohindra, Somya","role":"student","semester_id":7,"profile_id":20344265}},"semester":{"id":7,"tag":"sp22"}},"$$":[{"l":["auth","user","created_at"],"r":{"type":"Date","value":1642323656000}},{"l":["auth","user","updated_at"],"r":{"type":"Date","value":1642549110000}}]}</script><div id="app-root"><div class="rel" id="app-page"><header class="rel" id="app-header"><div><nav><!--M^s0-0-0-3-5 s0-0-0-3 5--><a href="/sp22">cs184/284a</a><!--M/--><!--M^s0-0-0-3-6 s0-0-0-3 6--><a href="/sp22/policies">policies</a><!--M/--><!--M^s0-0-0-3-7 s0-0-0-3 7--><a href="/sp22/staff">staff</a><!--M/--><!--M^s0-0-0-3-8 s0-0-0-3 8--><a href="/sp22/readings">readings</a><!--M/--><!--M^s0-0-0-3-9 s0-0-0-3 9--><a href="/sp22/resources">resources</a><!--M/--><!--M^s0-0-0-3-10 s0-0-0-3 10--><a href="/sp22/comments">comments</a><!--M/--></nav><div class="header-tail"><div class="header-auth"><a href="/auth/logout?r=/sp22" class="nav-link"><i class="icon ion-ios-log-out"></i></a><a href="/sp22/p/somyam" class="profile"><span class="avatar"><img src="https://avatars.githubusercontent.com/u/20344265?v=4"></span><span class="username">somyam</span></a></div></div></div></header><div class="full" id="app-page__body"><div class="article"><div class="article-header"><h1>Project 1: Rasterizer</h1></div><div class="article-body"><div class="comp-md markdown-body"><hr>
<p>
  <img src="https://cs184.eecs.berkeley.edu/cs184_sp16_content/article_images/3_1.jpg" width="800px" align="middle"/>
</p>
<p>In this assignment you will implement a simple rasterizer, including features like drawing triangles, supersampling, hierarchical transforms, and texture mapping with antialiasing. At the end, you'll have a functional vector graphics renderer that can take in a simplified version of SVG (Scalable Vector Graphics) files, which are widely used on the internet.</p>
<h2>Project Structure</h2>
<p>The project has 6 tasks, worth a total of 100 possible points. Some require only a few lines of code, while others are more substantial.</p>
<ul>
<li>
<p>Task 1: Drawing Single-Color Triangles (20 pts)</p>
</li>
<li>
<p>Task 2: Antialiasing by Supersampling (20 pts)</p>
</li>
<li>
<p>Task 3: Transforms (10 pts)</p>
</li>
<li>
<p>Task 4: Barycentric coordinates (10 pts)</p>
</li>
<li>
<p>Task 5: &quot;Pixel sampling&quot; for texture mapping (15 pts)</p>
</li>
<li>
<p>Task 6: &quot;Level sampling&quot; with mipmaps for texture mapping (25 pts)</p>
</li>
<li>
<p>Part 7: Extra Credit - Draw Something Creative!</p>
</li>
</ul>
<h2>Logistics</h2>
<h3>Deadline</h3>
<p>Project 1 is due <strong>Tuesday 02/15/2022, 11:59PM</strong>. Both your code and write-up need to be turned in for your submission to be complete; assignments which are turned in after 11:59pm will use one of your late days -- there are no late minutes or late hours.</p>
<h3>Partners</h3>
<p>You can work with a partner on this project. If you work with a partner, both of you should join the same team on Github Classroom. You should also produce 1 writeup and 1 gradescope submission with the partner added on.</p>
<h3>Checkpoint Quiz</h3>
<p><strong>There will be a checkpoint quiz for this project, due Tuesday 2/8, 11:59PM.</strong> This short quiz can be used to gain &quot;buffer points&quot; on the assignment. As long as you get at least 4 out of the 7 questions correct, AND submit a valid screenshot of your project building, you'll get the full 5 buffer points. For more information, please check the description in the checkpoint itself. <strong>The checkpoint quiz for Project 1 is available <a href="https://docs.google.com/forms/d/e/1FAIpQLSe1yDIQwNHS2Z-AJUouGmNhuth4A4kZcT874TOUhv0z-LC-Sg/viewform?usp=sf_link">here</a>.</strong></p>
<h3>Project Parties</h3>
<p>We will have 4 project parties:</p>
<table>
<thead>
<tr>
<th style="text-align:center">Date/Time</th>
<th style="text-align:center">Location</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Friday 2/4 3-5pm</td>
<td style="text-align:center">ohyay</td>
</tr>
<tr>
<td style="text-align:center">Monday 2/7 2-3:30pm</td>
<td style="text-align:center">Wozniak Lounge</td>
</tr>
<tr>
<td style="text-align:center">Thursday 2/10 12-1</td>
<td style="text-align:center">Cory 400 &amp; ohyay</td>
</tr>
<tr>
<td style="text-align:center">Monday 2/14 2-3:30pm</td>
<td style="text-align:center">Wozniak Lounge &amp; ohyay</td>
</tr>
</tbody>
</table>
<p>The online components of all parties will be through the class ohyay.</p>
<h3>Academic honesty</h3>
<p>Please do not post code to a public GitHub repository, even after the class is finished, since these assignments will be reused both here and at other universities in the future.</p>
<p>The assignments are to be completed individually. You are welcome to discuss the various parts of the assignments with your classmates, but you must implement the algorithms yourself -- you should never look at anyone else's code.</p>
<h3>Getting started</h3>
<p>First, accept the assignment in your CS184 website profile, following the instructions from GitHub Classroom. Then, clone the generated repo. Make sure you clone <em>your repo</em>, and not the class skeleton.</p>
<pre><code>$ git clone --recurse-submodule &lt;YOUR_PRIVATE_REPO&gt;
</code></pre>
<p>Also ensure GitHub Pages is enabled for your assignment.</p>
<p>Please consult this <a href="https://cs184.eecs.berkeley.edu/sp22/docs/building-assignments">how to build assignments for CS184</a> article for more information on how to setup and build the assignment.</p>
<p>As you go through the assignment, <a href="#rubric">refer to the write-up guidelines and deliverables section below</a>. <strong>It is recommended that you complete each section's write-up as you finish that section.</strong> It's generally not a good idea to wait until the end to start your writeup. You may also find it helpful to skim the rubric before beginning your work.</p>
<p><em>Important: To avoid compression artifacts in your images, please do not convert the PNG screenshot images saved by the GUI into JPG or other formats!  PNG images are losslessly compressed.</em></p>
<p>Finally, you may find the following resources helpful:</p>
<p><strong><a href="https://cs184.eecs.berkeley.edu/sp22/docs/cp-intro">C++ Guide</a></strong> for some quick tips and tricks on getting started with C++. A slightly more detailed C++ guide can be <a href="https://github.com/Bryce-Summers/Writings/blob/master/Programming%20Guides/C_plus_plus_guide.pdf">found here</a>.</p>
<p><strong><a href="https://cs184.eecs.berkeley.edu/sp22/docs/images-as-data">Images as Data</a></strong> on how images and colors are often represented in code.</p>
<p><strong><a href="https://cs184.eecs.berkeley.edu/sp22/docs/cgl-primer">Vectors and Matrices in the CGL Library</a></strong> for a quick refresher on declaring and using vectors and matrices.</p>
<p><strong><a href="https://cs184.eecs.berkeley.edu/sp22/docs/cgl-vector-docs">CGL Vectors API</a></strong> for the API listing of CGL Vectors library.</p>
<p>
  <img src="https://cs184.eecs.berkeley.edu/cs184_sp16_content/article_images/3_7.jpg" width="800px" align="middle"/>
</p>
<h3>Using the GUI</h3>
<p>You can run the executable with the command</p>
<pre><code>./draw [path to svg file/folder to render]
</code></pre>
<p>For example, you could run this command:</p>
<pre><code>./draw ../svg/basic/test1.svg
</code></pre>
<blockquote>
<p>Note:
For Visual Studio, the output folder is 3 layers deep. Therefore you should use <code>./draw ../../../svg/basic/test1.svg</code>
For Linux / Unix / Mac commandline build, it should be 1 layer deep: <code>./draw ../svg/basic/test1.svg</code>
All the IDEs has some form of debug / launch settings. You can use those to specify the SVG file and then you can use the debugger provided by the IDE.
Anyways, the path should always be relative to the executable file!</p>
</blockquote>
<p>You'll see a flower composed of blue dots, based on point and line rasterization provided in the starter code.  Most other SVG files won't render correctly until you work through the assignment. Here are the keyboard shortcuts available (some depend on you implementing various parts of the assignment):</p>
<table>
<thead>
<tr>
<th style="text-align:center">Key</th>
<th>Action</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><kbd>space</kbd></td>
<td>return to original viewpoint</td>
</tr>
<tr>
<td style="text-align:center"><kbd>-</kbd></td>
<td>decrease sample rate</td>
</tr>
<tr>
<td style="text-align:center"><kbd>=</kbd></td>
<td>increase sample rate</td>
</tr>
<tr>
<td style="text-align:center"><kbd>Z</kbd></td>
<td>toggle the pixel inspector</td>
</tr>
<tr>
<td style="text-align:center"><kbd>P</kbd></td>
<td>switch between texture filtering methods on pixels</td>
</tr>
<tr>
<td style="text-align:center"><kbd>L</kbd></td>
<td>switch between texture filtering methods on mipmap levels</td>
</tr>
<tr>
<td style="text-align:center"><kbd>S</kbd></td>
<td>save a <em>PNG</em> image screenshot in the current directory</td>
</tr>
<tr>
<td style="text-align:center"><kbd>1</kbd> - <kbd>9</kbd></td>
<td>switch between svg files in the loaded directory</td>
</tr>
</tbody>
</table>
<p>The argument passed to <code>draw</code> can either be a single file or a directory containing multiple <em>svg</em> files, as in</p>
<pre><code>./draw ../svg/basic/
</code></pre>
<p>If you load a directory with up to 9 files, you can switch between them using the number keys 1-9 on your keyboard.</p>
<h3>Familiarize Yourself with the Starter Code</h3>
<p>Most of your modifications will be constrained to implementing or modifying functions in <code>rasterizer.cpp</code>, <code>transforms.cpp</code> and <code>texture.cpp</code>.</p>
<p>In addition to modifying these, you will need to understand other source and header files as you work through the project.  As one example, the starter code for this and future assignments use the CGL library.  For this assignment, you may want to familiarize yourself with classes defined in <code>vector2D.h</code>, <code>matrix3x3.h</code> and <code>color.h</code>.</p>
<p>Here is a brief sketch of what happens when you launch <code>draw</code>: An <code>SVGParser</code> (in <code>svgparser.h/cpp</code>) reads in the input <em>svg</em> file(s), launches a OpenGL <code>Viewer</code> containing a <code>DrawRend</code> (in <code>drawrend.h/cpp</code>) renderer, which enters an infinite loop and waits for input from the mouse and keyboard. In <code>DrawRend::redraw()</code> function, the high-level drawing work is done by the various <code>SVGElement</code> child classes (in <code>svg.h/cpp</code>), which then pass their low-level point, line, and triangle rasterization data to appropriate methods of a <code>Rasterizer</code> class.</p>
<h3>A Simple Example: Drawing Points</h3>
<p>You are given starter code that already implements drawing of 2D points. To see how this works, begin by taking a look at <code>SVG::draw()</code> in <code>svg.h</code>. The SVG object draws all elements in the SVG file via a sequence of calls to their <code>draw()</code> functions.  Each element type calls an appropriate draw function on a <code>Rasterizer</code> object. In the case of the <code>Point</code> element type, <code>Point::draw()</code> eventually calls the concrete draw function implemented in <code>RasterizerImp::rasterize_point()</code> in <code>rasterizer.cpp</code>.  The position of SVG elements in an SVG file is defined in a local coordinate frame, so <code>Point::draw()</code> transforms the point's position into screen-space coordinates before passing it to <code>RasterizerImp::rasterize_point()</code>.</p>
<p>The function <code>RasterizerImp::rasterize_point()</code> is responsible for actually drawing the point. In this assignment we define screen space for an output image of size <code>(target_w, target_h)</code> as follows:</p>
<ul>
<li><code>(0, 0)</code> corresponds to the top-left of the output image</li>
<li><code>(target_w, target_h)</code> corresponds to the bottom-right of the output image</li>
<li><strong>Please assume that screen sample positions are located at half-integer coordinates in screen space. That is, the top-left sample point is at coordinate (0.5, 0.5), and the bottom-right sample point is at coordinate (target_w-0.5, target_h-0.5).</strong></li>
</ul>
<p><img src="https://github.com/stanford-cs248/draw-svg/raw/master/misc/coord_1spp.png?raw=true" alt="Sample locations"></p>
<p>You may also wish to read <a href="https://cs184.eecs.berkeley.edu/sp22/docs/images-as-data">this resource</a> for more detail on how colors and images are represented as data.</p>
<p>To rasterize points, we adopt the following rule: a point covers at most one screen sample: the closest sample to the point in screen space. This is implemented as follows, assuming (x, y) is the screen-space location of a point.</p>
<pre><code>int sx = (int) floor(x);
int sy = (int) floor(y);
</code></pre>
<p>Of course, the code should not attempt to modify the render target buffer at invalid pixel locations.</p>
<pre><code>if ( sx &lt; 0 || sx &gt;= target_w ) return;
if ( sy &lt; 0 || sy &gt;= target_h ) return;
</code></pre>
<p>If the points happen to be on screen, we fill in the pixel with the RGB color associated with the point.</p>
<pre><code>  rgb_framebuffer_target[3 * (y * width + x)    ] = (unsigned char)(c.r * 255);
  rgb_framebuffer_target[3 * (y * width + x) + 1] = (unsigned char)(c.g * 255);
  rgb_framebuffer_target[3 * (y * width + x) + 2] = (unsigned char)(c.b * 255);
</code></pre>
<p>(Note: In this assignment, we do not support partial transparency or alpha blending, even though this is part of the SVG file format.)</p>
<h2>Project Tasks</h2>
<h3>Task 1: Drawing Single-Color Triangles (20 pts)</h3>
<p><a href="https://cs184.eecs.berkeley.edu/sp22/lecture/2/digital-drawing"><strong>Relevant lecture: 2</strong></a></p>
<p>In this task, you will implement the <code>rasterize_triangle</code> function in <code>rasterizer.cpp</code>. Your solution should:</p>
<ul>
<li>Rasterize the triangle by using the sampling methods described in class.</li>
<li>For each pixel, please perform the point-in-triangle tests with a sample point in the center of the pixel, not the corner. The coordinates of your sample should be equal to an integer point plus (.5,.5).</li>
<li>In Part 2 you will implement sub-pixel supersampling, but here you should just sample once per pixel and call the <code>fill_pixel()</code> helper function. Follow the example in the <code>rasterize_point</code> function in the starter code.</li>
<li>To receive full credit, your implementation should assume that a sample on the boundary of the triangle is to be drawn. You are encouraged but not required to implement the OpenGL edge rules for samples lying exactly on an edge. Do make sure that none of your edges are left un-rasterized.</li>
<li>Your implementation should be at least as efficient as sampling only within the bounding box of the triangle (not simply every pixel in the framebuffer).</li>
<li>Your code should draw the triangle regardless of the winding order of the vertices (i.e. clockwise or counter-clockwise). Check <code>svg/basic/test6.svg</code>.</li>
</ul>
<p>When finished, you should be able to render test SVG files with single-color polygons (which are triangulated into triangles elsewhere in the code before being passed to your function.  Files <code>basic/test3.svg</code>, <code>basic/test4.svg</code>, <code>basic/test5.svg</code>, and <code>basic/test6.svg</code> should render correctly.</p>
<p>For convenience, here is a list of functions you will need to modify:</p>
<ol>
<li><code>RasterizerImp::rasterize_triangle()</code> function in <code>rasterizer.cpp</code>.</li>
</ol>
<p><strong>Extra Credit:</strong> Make your triangle rasterizer super fast (e.g., by factoring redundant arithmetic operations out of loops, minimizing memory access, and not checking every sample in the bounding box). Write about the optimizations you used. Use <code>clock()</code> or <code>std::chrono::high_resolution_clock</code> to get precise timing comparisons between your basic and optimized implementations.</p>
<h3>Task 2: Antialiasing by Supersampling (20 pts)</h3>
<p><a href="https://cs184.eecs.berkeley.edu/sp22/lecture/3/sampling-aliasing-and-antialiasi"><strong>Relevant lecture: 3</strong></a></p>
<p>Use supersampling to antialias your triangles. The <code>sample_rate</code> parameter in <code>DrawRend</code> (adjusted using the <code>-</code> and <code>=</code> keys) tells you how many samples to use per pixel.</p>
<p>The image below shows how sampling four times per pixel produces a better result than just sampling once.  The fraction of the supersamples within the triangle yields a smoother edge.</p>
<p>
  <img src="https://cs184.eecs.berkeley.edu/cs184_sp17_content/article_images/3_1.jpg" width="500px" align="middle"/>
</p>
<p>To implement supersampling, please sample at <code>sqrt(sample_rate) * sqrt(sample_rate)</code> grid locations distributed over the pixel area. (sample_rate is a member variable of the RasterizerImp class)</p>
<p>One reasonable way to think about supersampling is simply rasterizing an image that is higher resolution, then downsampling the higher resolution image to the output resolution of the framebuffer.</p>
<p>The original fill_pixel function used in Task 1 directly draws onto the framebuffer, but for supersampling, you should draw into the sample_buffer first, filling all the subsamples corresponding to the output pixel.</p>
<p>To reiterate the overall pipeline of the rasterizer:</p>
<ol>
<li>SVGParser parses the svg file into SVG class representation.</li>
<li>When rasterization starts, the renderer (<code>DrawRend::redraw</code>) calls SVG::draw.</li>
<li><code>SVG::draw</code> calls the specific line / triangle / point rasterization functions to generate the image primitive by primitive.</li>
<li><code>DrawRend::redraw</code> calls line rasterization to draw the square boundary.</li>
<li><code>DrawRend::redraw</code> calls <code>RasterizerImp::resolve_to_framebuffer()</code> to translate the internal buffer of the rasterizer to the screenbuffer so the image can be displayed and written into a file.</li>
</ol>
<p>Suggestions for this task:</p>
<ul>
<li>You will need to manage appropriate memory to store your supersample data.  We recommend that you use the <code>RasterizerImp::sample_buffer</code> vector (see file <code>rasterizer.h</code>) for this purpose.  It depends on your algorithm, but it is likely that the size of the sample buffer you need will depend on the framebuffer dimensions (which changes when the window is resized) and the supersampling rate (which changes with keystrokes as described above).  You will need to update the size of the buffer dynamically. There are hints below and in the code for where you may want to manage the size of your buffer.</li>
<li>Clear the values in your sample buffer memory and/or framebuffer appropriately at the beginning of redrawing the frame. This is erasing the frame before you start drawing.</li>
<li>Update your <code>rasterize_triangle</code> function to perform supersampling into your supersample buffer memory. There are multiple ways to organize the data in your supersample buffer, and the choice is up to you.
<ul>
<li>Based on the above way to think about supersampling, your sample buffer is just a temporary, higher-resolution framebuffer.  For example, 4x4 supersampling with a 1000x1000 pixel framebuffer means rasterizing a 4000x4000 (high-res) image of the scene into your sample buffer.  After you rasterize the high-res image, you need to downsample to 1000x1000 final pixels by averaging down the 4x4 grid of sample values that are related to each output pixel.  In this way of thinking, you need to store more memory in order to perform the high-res supersampled rasterization.  (Test your understanding: can you achieve the same results without needing more memory, and if so, what are the engineering tradeoffs?)</li>
</ul>
</li>
<li>At the end of rasterizing all the scene elements, you will need to populate the framebuffer from your supersamples.  This is sometimes called resolving the samples into the framebuffer.  Notice that the <strong><code>RasterizerImp::resolve_to_framebuffer</code></strong> function is called as the last step in rendering the frame <strong>in <code>drawrend.cpp</code></strong>, so you may wish to implement this part of your algorithm here.</li>
<li>Note that you will need to convert between different color datatypes. <code>RasterizerImp::rgb_framebuffer_target</code> stores a pointer to the framebuffer pixel data that is finally drawn to the display. <code>rgb_framebuffer_target</code> is an array of 8-bit values for each of the R, G and B components of each pixel's color -- this is the compact data format expected by most real graphics systems for drawing to the display.  In contrast, the <code>RasterizerImp::sample_buffer</code> variable that we suggest you use for your supersample memory is an array of <code>Color</code> objects that store R, G and B internally as floating point values.  You may wish to familiarize yourself with the <code>Color</code> class.  You may need to convert between these datatypes.  Watch out for floating point to integer conversion errors, such as rounding and overflow.</li>
<li>In most of graphics field, color is just the same as any other vector data: They are 3 dimensional (4 if it has the alpha channel). This means any XYZ vector representing a point or a direction could also represent a color. We will cover color space and color theory later in this course.</li>
<li>You will likely find that points and lines stop rendering correctly after your supersampling modifications. Lines and points are not supersampled, but they still need to be drawn into the supersample buffer. Modify <code>RasterizerImp::fill_pixel</code> if needed to restore functionality. One way to think about this is to fill all the supersamples corresponding to the point or line with the same color, so it comes out as a single sampled pixel in the framebuffer. You do NOT need to antialias points and lines.</li>
</ul>
<p>Once your implementation is complete, your triangle edges should look noticeably smoother when using more than one sample per pixel! You can examine the differences closely using the pixel inspector (see controls listed above). Also note that, it may take several seconds to switch to a higher sampling rate.</p>
<p>For convenience, here is a list of functions you will likely want to use or modify.</p>
<ol>
<li>For managing supersample buffer memory: <code>RasterizerImp::sample_buffer</code>,  <code>RasterizerImp::set_sample_rate()</code>, <code>RasterizerImp::set_framebuffer_target()</code>, <code>RasterizerImp::clear_buffers()</code> in <code>rasterizer.h/cpp</code>.</li>
<li>To implement triangle supersampling: <code>RasterizerImp::rasterize_triangle()</code>, <code>RasterizerImp::fill_pixel()</code>, in <code>rasterizer.cpp</code>.</li>
<li>For resolving supersamples to framebuffer: <code>RasterizerImp::resolve_to_framebuffer()</code>.</li>
</ol>
<p><strong>Extra Credit:</strong> Implement an alternative sampling pattern, such as jittered or low-discrepancy sampling. Create comparison images showing the differences between grid supersampling and your new pattern. Try making a scene that contains aliasing artifacts when rendered using grid supersampling but not when using your pattern.</p>
<h3>Task 3: Transforms (10 pts)</h3>
<p><a href="https://cs184.eecs.berkeley.edu/sp22/lecture/4/transforms"><strong>Relevant lecture: 4</strong></a></p>
<!--[**Relevant lecture: 4**](https://cs184.org/lecture/transforms-1)-->
<p>Implement the three transforms in the <em>transforms.cpp</em> file according to the <a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/transform">SVG spec</a>. The matrices are 3x3 because they operate in homogeneous coordinates -- you can see how they will be used on instances of <code>Vector2D</code> by looking at the way the <code>*</code> operator is overloaded in the same file.</p>
<p>Once you've implemented these transforms, <em>svg/transforms/robot.svg</em> should render correctly, as follows:</p>
<img src="https://cs184.eecs.berkeley.edu/cs184_sp17_content/article_images/3_.jpg" width="400px" align="middle"/>
<p>For convenience, here is a list of functions in <em>transforms.cpp</em> you will need to modify:</p>
<ol>
<li><code>translate</code></li>
<li><code>scale</code></li>
<li><code>rotate</code></li>
</ol>
<p><strong>Extra Credit:</strong> Add an extra feature to the GUI. For example, you could make two unused keys to rotate the viewport. Save an example image to demonstrate your feature, and write about how you modified the SVG to NDC and NDC to screen-space matrix stack to implement it.</p>
<h3>Task 4: Barycentric coordinates (10 pts)</h3>
<p><a href="https://cs184.eecs.berkeley.edu/sp22/lecture/5/texture-mapping"><strong>Relevant lecture: 5</strong></a></p>
<!--[**Relevant lecture: 6**](https://cs184.eecs.berkeley.edu/lecture/texture)-->
<p>Implement <code>RasterizerImp::rasterize_interpolated_color_triangle(...)</code> to draw a triangle with colors defined at the vertices and interpolated across the triangle area using barycentric interpolation.</p>
<p>Once Part 4 is done, you should be able to see a color wheel in <em>svg/basic/test7.svg</em> (below, right).</p>
<p>For convenience, here is a list of functions you will need to modify:</p>
<ol>
<li><code>RasterizerImp::rasterize_interpolated_color_triangle(...)</code></li>
</ol>
<p>
  <img src="https://cs184.eecs.berkeley.edu/cs184_sp16_content/article_images/3_4.jpg" width="800px" align="middle"/>
</p>
<h3>Task 5: &quot;Pixel sampling&quot; for texture mapping (15 pts)</h3>
<p><a href="https://cs184.eecs.berkeley.edu/sp22/lecture/5/texture-mapping"><strong>Relevant lecture: 5</strong></a></p>
<p>Implement <code>RasterizerImp::rasterize_textured_triangle(...)</code> to draw a triangle with colors defined by texture mapping with the given 2D texture coordinates at each vertex and the given <code>Texture</code> image.  Here in Task 5 you will implement texture sampling on the full-resolution texture image using nearest neighbor and bilinear interpolation, as described in lecture.</p>
<p>The GUI toggles <code>RasterizerImp</code>'s <code>PixelSampleMethod</code> variable <code>psm</code> using the <code>'P'</code> key. When <code>psm == P_NEAREST</code>, you should use nearest-pixel sampling, and when <code>psm == P_LINEAR</code>, you should use bilinear sampling.  Please do so by implementing <code>Texture::sample_nearest</code> and <code>Texture::sample_bilinear</code> functions and calling them from <code>RasterizerImp::rasterize_textured_triangle(...)</code>.  This approach will allow you to reuse these functions for trilinear texture filtering  in Task 6.</p>
<p>Once Part 5 is done, you should be able to rasterize the <em>svg</em> files in <em>svg/texmap/</em>, which rely on texture maps.</p>
<p>Notes:</p>
<ul>
<li>The <code>Texture</code> struct in <code>texture.h</code> stores a mipmap, as described in lecture, of texture images in decreasing resolution, in the <code>mipmap</code> variable. Each texture image is stored as an object of type <code>MipLevel</code>.</li>
<li><code>MipLevel::texels</code> stores the texture image pixels in the typical RGB format described above for framebuffer pixels.</li>
<li><code>MipLevel::get_texel(...)</code> may be helpful.</li>
<li>At this part of the project, you haven't implemented level sampling (mip-mapping) yet, so the program should default to zero-th level (full resolution).</li>
</ul>
<p>For convenience, here is a list of functions you will need to modify:</p>
<ol>
<li><code>RasterizerImp::rasterize_textured_triangle</code></li>
<li><code>Texture::sample_nearest</code></li>
<li><code>Texture::sample_bilinear</code></li>
</ol>
<h3>Task 6: &quot;Level sampling&quot; with mipmaps for texture mapping (25 pts)</h3>
<p><a href="https://cs184.eecs.berkeley.edu/sp22/lecture/5/texture-mapping"><strong>Relevant lecture: 5</strong></a></p>
<p>Finally, update <code>RasterizerImp::rasterize_textured_triangle(...)</code> to support sampling different mipmap levels (<code>MipLevel</code>s). The GUI toggles <code>RasterizerImp</code>'s <code>LevelSampleMethod</code> variable <code>lsm</code> using the <kbd>L</kbd> key. <strong>Please implement the following level sampling methods in the helper function <code>Texture::sample</code>.</strong></p>
<ul>
<li>When <code>lsm == L_ZERO</code>, you should sample from the zero-th <code>MipLevel</code>, as in Part 5.</li>
<li>When <code>lsm == L_NEAREST</code>, you should compute the nearest appropriate mipmap level and pass that level as a parameter to the nearest or bilinear sample function.</li>
<li>When <code>lsm == L_LINEAR</code>, you should compute the mipmap level as a continuous number. Then compute a weighted sum of using one sample from each of the adjacent mipmap levels as described in lecture.</li>
</ul>
<p>In addition, implement <code>Texture::get_level</code> as a helper function. You will need <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mfrac><mrow><mi>d</mi><mi>u</mi></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo separator="true">,</mo><mfrac><mrow><mi>d</mi><mi>v</mi></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo>)</mo></mrow><annotation encoding="application/x-tex">(\frac{du}{dx}, \frac{dv}{dx})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8801079999999999em;"></span><span class="strut bottom" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">d</span><span class="mord mathit">x</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">u</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mpunct">,</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">d</span><span class="mord mathit">x</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit" style="margin-right:0.03588em;">v</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mclose">)</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mfrac><mrow><mi>d</mi><mi>u</mi></mrow><mrow><mi>d</mi><mi>y</mi></mrow></mfrac><mo separator="true">,</mo><mfrac><mrow><mi>d</mi><mi>v</mi></mrow><mrow><mi>d</mi><mi>y</mi></mrow></mfrac><mo>)</mo></mrow><annotation encoding="application/x-tex">(\frac{du}{dy}, \frac{dv}{dy})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8801079999999999em;"></span><span class="strut bottom" style="height:1.3612159999999998em;vertical-align:-0.481108em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">d</span><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">u</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mpunct">,</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">d</span><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit" style="margin-right:0.03588em;">v</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mclose">)</span></span></span></span> to calculate the correct mipmap level. In order to get these values corresponding to a point <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> inside a triangle, you must perform the following.</p>
<ol>
<li>Calculate the <em>uv</em> barycentric coordinates of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x+1,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit">x</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>, and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,y+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span> in <code>rasterize_textured_triangle(...)</code> as <code>sp.p_uv</code>, <code>sp.p_dx_uv</code>, and <code>sp.p_dy_uv</code>, assign them to a <code>SampleParams</code> struct <code>sp</code>, along with other values required by the struct, and pass <code>sp</code> to <code>Texture::get_level</code></li>
<li>Calculate the difference vectors <code>sp.p_dx_uv - sp.p_uv</code> and <code>sp.p_dy_uv - sp.p_uv</code> inside <code>Texture::get_level</code>, and finally</li>
<li>Scale up the difference vectors <strong>accordingly</strong> by the width and height of the full-resolution texture image.</li>
</ol>
<p>With these, you can proceed with the calculation from the lecture slides.</p>
<p>Notes:</p>
<ul>
<li>The <code>lsm</code> and <code>psm</code> variables can be set independently and interacted independently. In other words, all combinations of <code>psm==[P_NEAREST, P_LINEAR] x lsm==[L_ZERO, L_NEAREST, L_LINEAR]</code> are valid.</li>
<li>When <code>lsm == L_LINEAR</code> and <code>psm == P_LINEAR</code>, this is known as trilinear sampling, or trilinear texture filtering, as described in lecture.</li>
<li>You may find it helpful to visualize what parts of the image use different levels of the mipmap. One way to do this is by normalizing the value returned by <code>Texture::get_level</code> by the maximum level (i.e. size of the mipmap) and have that value returned by <code>Texture::sample</code> as a color. Zoom in and out of the image to see how the levels change. This is a great way to both debug your implementation as well as gain intuition about level sampling! See below for two examples, where we zoom out/in to illustrate how the computed levels change.</li>
<li>Please be careful do not make copies of an entire Miplevel. Make sure you always use a pointer or a reference to access the miplevel. Copying entire miplevels as arguments is extremely slow!</li>
</ul>
<p>For convenience, here is a list of functions you will need to modify:</p>
<ol>
<li><code>RasterizerImp::rasterize_textured_triangle</code></li>
<li><code>Texture::sample</code></li>
<li><code>Texture::get_level</code></li>
</ol>
<p><strong>Extra Credit:</strong> Implement <a href="https://en.wikipedia.org/wiki/Anisotropic_filtering">anisotropic filtering</a> or <a href="https://en.wikipedia.org/wiki/Summed_area_table">summed area tables</a>. Show comparisons of your method to nearest, bilinear, and trilinear sampling. Use <code>clock()</code> to measure the relative performance of the methods.</p>
<h2>Potential Extra Credit - Draw Something Creative!</h2>
<p>Use your newfound powers to render something fun. You can look up the svg specifications online for matrix transforms and for Point, Line, Polyline, Rect, Polygon, and Group classes. The ColorTri and TexTri are our own inventions, so you can intuit their parameters by looking at the svgparser.cpp file. You can either try to draw something &quot;by hand&quot; or try to output an interesting pattern programmatically. For example, we wrote some simple programs to generate the texture mapped <em>svg</em> files in the <em>texmap</em> directory as well as the color wheel in <em>basic/test7.svg</em>.</p>
<p>Flex your right or left brain -- either show us your artistic side, or generate awesome procedural patterns with code. This could involve a lot of programming either inside or outside of the codebase! If you write a script to generate procedural <em>svg</em> files, include it in your submission and briefly explain how it works.</p>
<p><strong>Tips and guidelines for your submission:</strong></p>
<ul>
<li>Your resulting <em>png</em> screenshot should be 800x800 resolution. Keep this in mind when writing your <em>svg</em> file.</li>
<li>Use the GUI's <code>'S'</code> functionality to save your screenshot as a <em>png</em>. Don't take your own screenshot of your rasterized result, or you'll ruin the quality of your hard work!</li>
<li>Note: The rasterizer cannot display svg Path elements, so do not include any curves in the svg you wish to load.</li>
</ul>
<p>Students will vote on their favorite submissions and the top voted submission(s) will receive extra credit! More details regarding the art competition will be announced next week. Stay in tune!</p>
<h2>Submission</h2>
<p>Please consult this article on <a href="https://cs184.eecs.berkeley.edu/sp22/docs/submitting-assignments">how to submit the assignment for CS184</a>.</p>
<p>You will submit your code as well as some deliverables (see below) in a webpage project write-up.</p>
<h3>Project write-up guidelines and instructions</h3>
<p>We have provided a simple HTML skeleton in <em>index.html</em> found within the <em>docs</em> directory to help you get started and structure your write-up.</p>
<p>You are also welcome to create your own webpage report from scratch using your own preferred frameworks or tools. However, <strong>please follow the same overall structure as described in the deliverables section below</strong>.</p>
<p>The goals of your write-up are for you to (a) think about and articulate what you've built and learned in your own words, (b) have a write-up of the project to take away from the class. Your write-up should include:</p>
<ul>
<li>An overview of the project, your approach to and implementation for each of the parts, and what problems you encountered and how you solved them. Strive for clarity and succinctness.</li>
<li>On each part, make sure to include the results described in the corresponding Deliverables section in addition to your explanation. If you failed to generate any results correctly, provide a brief explanation of why.</li>
<li>The final (optional) part for the art competition is where you have the opportunity to be creative and individual, so be sure to provide a good description of what you were going for and how you implemented it.</li>
<li>Clearly indicate any extra credit items you completed, and provide a thorough explanation and illustration for each of them.</li>
</ul>
<p>The write-up is one of our main methods of evaluating your work, so it is important to spend the time to do it correctly and thoroughly. Plan ahead to allocate time for the write-up well before the deadline.</p>
<h3><a name="rubric"></a>Project Write-up Deliverables and Rubric</h3>
<p>Note that this rubric is rather coarse. The content and quality of your write-up are extremely important, and you should make sure to at <em>least</em> address all the points listed below. The extra credit portions are intended for students who want to challenge themselves and explore methods beyond the fundamentals, and are not worth a large amount of points. In other words, don't necessarily expect to use the extra credit points on these projects to make up for lost points elsewhere.</p>
<h4>Overview</h4>
<p>Give a high-level overview of what you implemented in this project. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the project.</p>
<h4>Task 1 (20 pts)</h4>
<ul>
<li>Walk through how you rasterize triangles in your own words.</li>
<li>Explain how your algorithm is no worse than one that checks each sample within the bounding box of the triangle.</li>
<li>Show a <em>png</em> screenshot of <em>basic/test4.svg</em> with the default viewing parameters and with the pixel inspector centered on an interesting part of the scene.</li>
<li><em>Extra credit:</em> Explain any special optimizations you did beyond simple bounding box triangle rasterization, with a timing comparison table (we suggest using the c++ <code>clock()</code> function around the <code>svg.draw()</code> command in <code>DrawRend::redraw()</code> to compare millisecond timings with your various optimizations off and on).</li>
</ul>
<h4>Task 2 (20 pts)</h4>
<ul>
<li>Walk through your supersampling algorithm and data structures. Why is supersampling useful? What modifications did you make to the rasterization pipeline in the process? Explain how you used supersampling to antialias your triangles.</li>
<li>Show <em>png</em> screenshots of <em>basic/test4.svg</em> with the default viewing parameters and sample rates 1, 4, and 16 to compare them side-by-side. Position the pixel inspector over an area that showcases the effect dramatically; for example, a very skinny triangle corner. Explain why these results are observed.</li>
<li><em>Extra credit:</em> If you implemented alternative antialiasing methods, describe them and include comparison pictures demonstrating the difference between your method and grid-based supersampling.</li>
</ul>
<h4>Task 3 (10 pts)</h4>
<ul>
<li>Create an updated version of <em>svg/transforms/robot.svg</em> with cubeman doing something more interesting, like waving or running. Feel free to change his colors or proportions to suit your creativity. Save your <em>svg</em> file as <em>my_robot.svg</em> in your <em>docs/</em> directory and show a <em>png</em> screenshot of your rendered drawing in your write-up. Explain what you were trying to do with cubeman in words.</li>
</ul>
<h4>Task 4 (10 pts)</h4>
<ul>
<li>Explain barycentric coordinates in your own words and use an image to aid you in your explanation. One idea is to use a <em>svg</em> file that plots a single triangle with one red, one green, and one blue vertex, which should produce a smoothly blended color triangle.</li>
<li>Show a <em>png</em> screenshot of <em>svg/basic/test7.svg</em> with default viewing parameters and sample rate 1. If you make any additional images with color gradients, include them.</li>
</ul>
<h4>Task 5 (15 pts)</h4>
<ul>
<li>Explain pixel sampling in your own words and describe how you implemented it to perform texture mapping. Briefly discuss the two different pixel sampling methods, nearest and bilinear.</li>
<li>Check out the <em>svg</em> files in the <em>svg/texmap/</em> directory. Use the pixel inspector to find a good example of where bilinear sampling clearly defeats nearest sampling. Show and compare four <em>png</em> screenshots using nearest sampling at 1 sample per pixel, nearest sampling at 16 samples per pixel, bilinear sampling at 1 sample per pixel, and bilinear sampling at 16 samples per pixel.</li>
<li>Comment on the relative differences. Discuss when there will be a large difference between the two methods and why.</li>
</ul>
<h4>Task 6 (25 pts)</h4>
<ul>
<li>Explain level sampling in your own words and describe how you implemented it for texture mapping.</li>
<li>You can now adjust your sampling technique by selecting pixel sampling, level sampling, or the number of samples per pixel. Describe the tradeoffs between speed, memory usage, and antialiasing power between the three various techniques.</li>
<li>Using a <em>png</em> file you find yourself, show us four versions of the image, using the combinations of <code>L_ZERO</code> and <code>P_NEAREST</code>, <code>L_ZERO</code> and <code>P_LINEAR</code>, <code>L_NEAREST</code> and <code>P_NEAREST</code>, as well as <code>L_NEAREST</code> and <code>P_LINEAR</code>.
<ul>
<li>To use your own <em>png</em>, make a copy of one of the existing <em>svg</em> files in <em>svg/texmap/</em> (or create your own modelled after one of the provided <em>svg</em> files). Then, near the top of the file, change the texture filename to point to your own <em>png</em>. From there, you can run ./draw and pass in that svg file to render it and then save a screenshot of your results.</li>
<li><strong>Note</strong>: Choose a <em>png</em> that showcases the different sampling effects well. You may also want to zoom in/out, use the pixel inspector, etc. to demonstrate the differences.</li>
</ul>
</li>
<li><em>Extra credit:</em> If you implemented any extra filtering methods, describe them and show comparisons between your results with the other above methods.</li>
</ul>
<h4>(Optional) Potential Extra Credit</h4>
<ul>
<li>Save your best <em>svg</em> file as <em>competition.svg</em> in your <em>docs/</em> directory, and show us a 800x800 <em>png</em> screenshot of it in your write-up!</li>
<li>Explain how you did it. If you wrote a script to generate procedural <em>svg</em> files, include it in your submission in the <em>src/</em> directory and briefly explain how it works.</li>
</ul>
<h3>Website tips and advice</h3>
<ul>
<li>Please include a link to your webpage at the bottom of your writeup</li>
<li>Note that only <em>one</em> webpage is needed for both partners</li>
<li>Be sure to include and turn in all of the other files (such as images) that are linked in your report!</li>
<li>Use only <em>relative</em> paths to files, such as <code>&quot;./images/image.jpg&quot;</code></li>
<li>Do <em>NOT</em> use absolute paths, such as <code>&quot;/Users/student/Desktop/image.jpg&quot;</code></li>
<li>Pay close attention to your filename extensions. Remember that on UNIX systems (such as the instructional machines), capitalization matters. <code>.png != .jpeg != .jpg != .JPG</code></li>
<li>Be sure to adjust the permissions on your files so that they are world readable. For more information on this please see this <a href="http://www.grymoire.com/Unix/Permissions.html%22">tutorial</a>.</li>
<li>Start assembling your webpage early to make sure you have a handle on how to edit the HTML code to insert images and format sections. (Or you can use Markdown)</li>
</ul>
<h2>Feedback Form</h2>
<p>Please fill out this <strong>optional</strong> <a href="https://forms.gle/aqht7oobkLemdaEd9">feedback from</a> if you would like to share any feedback on this project, the project parties, or the course in general with course staff</p>
</div></div></div></div><footer id="app-footer"></footer></div></div><script src="/static/cs184-web-a09c6a18.js"></script>
<script>$_mod_cal184.ready();</script><script>(function(){var w=window;w.$components=(w.$components||[]).concat({"r":"M","w":[["s0-0-0-3-10",0,{"to":"/comments","l":"comments"},{"f":1,"s":{"active":false},"w":{"target":"/sp22/comments"}}],["s0-0-0-3-9",0,{"to":"/resources","l":"resources"},{"f":1,"s":{"active":false},"w":{"target":"/sp22/resources"}}],["s0-0-0-3-8",0,{"to":"/readings","l":"readings"},{"f":1,"s":{"active":false},"w":{"target":"/sp22/readings"}}],["s0-0-0-3-7",0,{"to":"/staff","l":"staff"},{"f":1,"s":{"active":false},"w":{"target":"/sp22/staff"}}],["s0-0-0-3-6",0,{"to":"/policies","l":"policies"},{"f":1,"s":{"active":false},"w":{"target":"/sp22/policies"}}],["s0-0-0-3-5",0,{"to":"/","l":"cs184/284a"},{"f":1,"s":{"active":false},"w":{"target":"/sp22"}}]],"t":["/cal-184-website$3.2.0/client/components/comp-nav-link/index.marko"]})||w.$components})()</script></body></html>
