
<!DOCTYPE html>
<html lang="en"><head><title>cs184/284a</title><meta charset="UTF-8"><meta http-equiv="Content-Language" content="en"><link rel="stylesheet" href="https://unpkg.com/ionicons@4.4.2/dist/css/ionicons.min.css">
<link rel="stylesheet" href="/static/cs184-web-5d805804.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/github-markdown-css/2.2.1/github-markdown.css">
<p>
  <img src="https://cs184.eecs.berkeley.edu/cs184_sp16_content/article_images/3_1.jpg" width="800px" align="middle"/>
</p>
<h3>Project 1 Rasterizer By Somya Mohindra </h3>
<h4>Overview</h4>
<p>A rasterizer takes descriptions of coordinates and renders them into pixel values we can display on our screens. This project focused on triangle rasterization that includes antialiasing techniques like supersampling, sampling, and level sampling of multiple mipmaps. The rasterizer also handles affine transformations including rotation, scaling, and translation. The most interesting part of this project was discovering the significant image improvements that came from implementing each of the antialiasing techniques when doing texture mapping. 
</p
<h4>Task 1</h4>
<ul>
<li>Walk through how you rasterize triangles in your own words.</li>
<p>We first calculate the bounding box of the triangle by finding the minimum and maximum x value and y values. Then we do a three line test (prewritten in the “inside” function within triangulation.cpp) to see if a given sample point is within the triangle of interest. We only need to sample the points within our bounding box, rather than in our entire pixel buffer. The “inside” function calculates the lines formed by all three triangle vertices. Then, it calculates if the vectors formed from the sample point to these lines are all positive (if using counter-clockwise edge lines) or all negative (if using clockwise edge lines). For all the sample points inside our triangle, we assign the sample buffer at the (x,y) pairing equal to the given color.
  </p>
<li>Explain how your algorithm is no worse than one that checks each sample within the bounding box of the triangle.</li>
  <p> As explained earlier, the algorithm only scans the samples within the calculated bounding box of the triangle to see if they are contained within the triangle, therefore, it is not any worse, but it is also not any better.
  </p>
<li>Show a <em>png</em> screenshot of <em>basic/test4.svg</em> with the default viewing parameters and with the pixel inspector centered on an interesting part of the scene.</li>
<li><em>Extra credit:</em> Explain any special optimizations you did beyond simple bounding box triangle rasterization, with a timing comparison table (we suggest using the c++ <code>clock()</code> function around the <code>svg.draw()</code> command in <code>DrawRend::redraw()</code> to compare millisecond timings with your various optimizations off and on).</li>
</ul>
<h4>Task 2</h4>
<ul>
<li>Walk through your supersampling algorithm and data structures. Why is supersampling useful? What modifications did you make to the rasterization pipeline in the process? Explain how you used supersampling to antialias your triangles.</li>
<p>Supersampling is the process of sampling many (sample_rate) times per pixel and averaging those samples to blur and filter out higher frequencies. This reduces the appearance of aliasing, by allowing us to surpass the Nyquist frequency. The first modification I made was to sample_buffer, resizing it to be a 1D list of size width*height*sample_rate to collect all the supersample colors. This length changes as the user changes supersample rate. In rasterize_triangle, I first looped over the pixels within the bounding box of the triangle (which I also did in task 1). For each sample (x,y), I incremented each of the coordinate values by 1/sqrt(sample_rate) as many times as possible while staying within the bounds of the pixel. I offset these supersamples by ½*sqrt(sample_rate) in order to start the supersampling at an appropriate location. I saved the color of the supersample (sx,sy) into the sample_buffer. In resolve_to_framebuffer, I averaged the colors of every set of sample_rate samples and placed the final color values into the frame_buffer. For example, if my sample_rate is 4, I took every 4 indices in the sample_buffer, averaged their color values and placed the output in the frame_buffer. 
  </p>
  <li>Show <em>png</em> screenshots of <em>basic/test4.svg</em> with the default viewing parameters and sample rates 1, 4, and 16 to compare them side-by-side. Position the pixel inspector over an area that showcases the effect dramatically; for example, a very skinny triangle corner. Explain why these results are observed.</li>
</ul>
<h4>Task 3</h4>
<ul>
<li>Create an updated version of <em>svg/transforms/robot.svg</em> with cubeman doing something more interesting, like waving or running. Feel free to change his colors or proportions to suit your creativity. Save your <em>svg</em> file as <em>my_robot.svg</em> in your <em>docs/</em> directory and show a <em>png</em> screenshot of your rendered drawing in your write-up. Explain what you were trying to do with cubeman in words.</li>
</ul>
<h4>Task 4</h4>
<ul>
<li>Explain barycentric coordinates in your own words and use an image to aid you in your explanation. One idea is to use a <em>svg</em> file that plots a single triangle with one red, one green, and one blue vertex, which should produce a smoothly blended color triangle.</li>
<li>Show a <em>png</em> screenshot of <em>svg/basic/test7.svg</em> with default viewing parameters and sample rate 1. If you make any additional images with color gradients, include them.</li>
</ul>
<h4>Task 5</h4>
<ul>
<li>Explain pixel sampling in your own words and describe how you implemented it to perform texture mapping. Briefly discuss the two different pixel sampling methods, nearest and bilinear.</li>
<li>Check out the <em>svg</em> files in the <em>svg/texmap/</em> directory. Use the pixel inspector to find a good example of where bilinear sampling clearly defeats nearest sampling. Show and compare four <em>png</em> screenshots using nearest sampling at 1 sample per pixel, nearest sampling at 16 samples per pixel, bilinear sampling at 1 sample per pixel, and bilinear sampling at 16 samples per pixel.</li>
<li>Comment on the relative differences. Discuss when there will be a large difference between the two methods and why.</li>
</ul>
<h4>Task 6</h4>
<ul>
<li>Explain level sampling in your own words and describe how you implemented it for texture mapping.</li>
<li>You can now adjust your sampling technique by selecting pixel sampling, level sampling, or the number of samples per pixel. Describe the tradeoffs between speed, memory usage, and antialiasing power between the three various techniques.</li>
<li>Using a <em>png</em> file you find yourself, show us four versions of the image, using the combinations of <code>L_ZERO</code> and <code>P_NEAREST</code>, <code>L_ZERO</code> and <code>P_LINEAR</code>, <code>L_NEAREST</code> and <code>P_NEAREST</code>, as well as <code>L_NEAREST</code> and <code>P_LINEAR</code>.
<ul>
<li>To use your own <em>png</em>, make a copy of one of the existing <em>svg</em> files in <em>svg/texmap/</em> (or create your own modelled after one of the provided <em>svg</em> files). Then, near the top of the file, change the texture filename to point to your own <em>png</em>. From there, you can run ./draw and pass in that svg file to render it and then save a screenshot of your results.</li>
<li><strong>Note</strong>: Choose a <em>png</em> that showcases the different sampling effects well. You may also want to zoom in/out, use the pixel inspector, etc. to demonstrate the differences.</li>
</ul>
</li>
</ul>
